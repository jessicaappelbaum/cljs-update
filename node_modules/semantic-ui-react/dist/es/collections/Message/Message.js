import _extends from 'babel-runtime/helpers/extends';
import _without from 'lodash/without';
import _isNil from 'lodash/isNil';

import React, { PropTypes } from 'react';
import cx from 'classnames';

import { createShorthand, customPropTypes, getElementType, getUnhandledProps, META, SUI, useKeyOnly, useKeyOrValueAndKey } from '../../lib';
import Icon from '../../elements/Icon';

import MessageContent from './MessageContent';
import MessageHeader from './MessageHeader';
import MessageList from './MessageList';
import MessageItem from './MessageItem';

/**
 * A message displays information that explains nearby content
 * @see Form
 */
function Message(props) {
  var children = props.children,
      className = props.className,
      content = props.content,
      header = props.header,
      icon = props.icon,
      list = props.list,
      onDismiss = props.onDismiss,
      hidden = props.hidden,
      visible = props.visible,
      floating = props.floating,
      compact = props.compact,
      attached = props.attached,
      warning = props.warning,
      info = props.info,
      positive = props.positive,
      success = props.success,
      negative = props.negative,
      error = props.error,
      color = props.color,
      size = props.size;


  var classes = cx('ui', size, color, useKeyOnly(icon, 'icon'), useKeyOnly(hidden, 'hidden'), useKeyOnly(visible, 'visible'), useKeyOnly(floating, 'floating'), useKeyOnly(compact, 'compact'), useKeyOrValueAndKey(attached, 'attached'), useKeyOnly(warning, 'warning'), useKeyOnly(info, 'info'), useKeyOnly(positive, 'positive'), useKeyOnly(success, 'success'), useKeyOnly(negative, 'negative'), useKeyOnly(error, 'error'), 'message', className);

  var dismissIcon = onDismiss && React.createElement(Icon, { name: 'close', onClick: onDismiss });
  var rest = getUnhandledProps(Message, props);
  var ElementType = getElementType(Message, props);

  if (!_isNil(children)) {
    return React.createElement(
      ElementType,
      _extends({}, rest, { className: classes }),
      dismissIcon,
      children
    );
  }

  return React.createElement(
    ElementType,
    _extends({}, rest, { className: classes }),
    dismissIcon,
    Icon.create(icon),
    (!_isNil(header) || !_isNil(content) || !_isNil(list)) && React.createElement(
      MessageContent,
      null,
      MessageHeader.create(header),
      MessageList.create(list),
      createShorthand('p', function (val) {
        return { children: val };
      }, content)
    )
  );
}

Message.handledProps = ['as', 'attached', 'children', 'className', 'color', 'compact', 'content', 'error', 'floating', 'header', 'hidden', 'icon', 'info', 'list', 'negative', 'onDismiss', 'positive', 'size', 'success', 'visible', 'warning'];
Message._meta = {
  name: 'Message',
  type: META.TYPES.COLLECTION,
  props: {
    attached: ['bottom'],
    color: SUI.COLORS,
    size: _without(SUI.SIZES, 'medium')
  }
};

process.env.NODE_ENV !== "production" ? Message.propTypes = {
  /** An element type to render as (string or function). */
  as: customPropTypes.as,

  /** Primary content. */
  children: PropTypes.node,

  /** Additional classes. */
  className: PropTypes.string,

  /** Shorthand for primary content. */
  content: customPropTypes.contentShorthand,

  /** Shorthand for MessageHeader. */
  header: customPropTypes.itemShorthand,

  /** A message can contain an icon. */
  icon: PropTypes.oneOfType([PropTypes.bool, customPropTypes.itemShorthand]),

  /** Array shorthand items for the MessageList. Mutually exclusive with children. */
  list: customPropTypes.collectionShorthand,

  /**
   * A message that the user can choose to hide.
   * Called when the user clicks the "x" icon. This also adds the "x" icon.
   */
  onDismiss: PropTypes.func,

  /** A message can be hidden. */
  hidden: PropTypes.bool,

  /** A message can be set to visible to force itself to be shown. */
  visible: PropTypes.bool,

  /** A message can float above content that it is related to. */
  floating: PropTypes.bool,

  /** A message can only take up the width of its content. */
  compact: PropTypes.bool,

  /** A message can be formatted to attach itself to other content. */
  attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(Message._meta.props.attached)]),

  /** A message may be formatted to display warning messages. */
  warning: PropTypes.bool,

  /** A message may be formatted to display information. */
  info: PropTypes.bool,

  /** A message may be formatted to display a positive message.  Same as `success`. */
  positive: PropTypes.bool,

  /** A message may be formatted to display a positive message.  Same as `positive`. */
  success: PropTypes.bool,

  /** A message may be formatted to display a negative message. Same as `error`. */
  negative: PropTypes.bool,

  /** A message may be formatted to display a negative message. Same as `negative`. */
  error: PropTypes.bool,

  /** A message can be formatted to be different colors. */
  color: PropTypes.oneOf(Message._meta.props.color),

  /** A message can have different sizes. */
  size: PropTypes.oneOf(Message._meta.props.size)
} : void 0;

Message.Content = MessageContent;
Message.Header = MessageHeader;
Message.List = MessageList;
Message.Item = MessageItem;

export default Message;